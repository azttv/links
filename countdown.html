<!doctype html>
<html lang="fr">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Renouveau</title>
        <link
            href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500;600&display=swap"
            rel="stylesheet"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <style>
            *,
            *::before,
            *::after {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                overflow: hidden;
                background: #0a0a0a;
                width: 100vw;
                height: 100vh;
            }

            #ascii-container {
                position: fixed;
                inset: 0;
                width: 100%;
                height: 100%;
            }

            #ascii-container canvas {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                image-rendering: pixelated;
            }

            #ascii-container pre {
                margin: 0;
                user-select: none;
                padding: 0;
                line-height: 1em;
                text-align: left;
                position: absolute;
                left: 0;
                top: 0;
                background-image: radial-gradient(
                    circle,
                    #ff6188 0%,
                    #fc9867 50%,
                    #ffd866 100%
                );
                background-attachment: fixed;
                -webkit-text-fill-color: transparent;
                -webkit-background-clip: text;
                background-clip: text;
                z-index: 9;
                mix-blend-mode: difference;
            }
        </style>
    </head>
    <body>
        <div id="ascii-container"></div>
        <audio id="bg-music" loop preload="auto">
            <source src="noise.wav" type="audio/wav" />
        </audio>
        <script>
            // ============================================
            //  SET YOUR COUNTDOWN END DATE HERE
            // ============================================
            const TARGET_DATE = new Date("2026-09-11T16:00:00");
            // ============================================

            // ============================================================
            //  ASCII TEXT ANIMATION â€” Faithful port of ReactBits AsciiText
            //  Original: https://reactbits.dev/text-animations/ascii-text
            // ============================================================

            Math.map = function (n, start, stop, start2, stop2) {
                return (
                    ((n - start) / (stop - start)) * (stop2 - start2) + start2
                );
            };

            const PX_RATIO = window.devicePixelRatio || 1;

            class AsciiFilter {
                constructor(
                    renderer,
                    { fontSize, fontFamily, charset, invert } = {},
                ) {
                    this.renderer = renderer;
                    this.domElement = document.createElement("div");
                    this.domElement.style.position = "absolute";
                    this.domElement.style.top = "0";
                    this.domElement.style.left = "0";
                    this.domElement.style.width = "100%";
                    this.domElement.style.height = "100%";

                    this.pre = document.createElement("pre");
                    this.domElement.appendChild(this.pre);

                    this.canvas = document.createElement("canvas");
                    this.context = this.canvas.getContext("2d");
                    this.domElement.appendChild(this.canvas);

                    this.deg = 0;
                    this.invert = invert ?? true;
                    this.fontSize = fontSize ?? 12;
                    this.fontFamily = fontFamily ?? "'Courier New', monospace";
                    this.charset =
                        charset ??
                        " .'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";

                    this.context.webkitImageSmoothingEnabled = false;
                    this.context.mozImageSmoothingEnabled = false;
                    this.context.msImageSmoothingEnabled = false;
                    this.context.imageSmoothingEnabled = false;

                    this.onMouseMove = this.onMouseMove.bind(this);
                    document.addEventListener("mousemove", this.onMouseMove);
                }

                setSize(width, height) {
                    this.width = width;
                    this.height = height;
                    this.renderer.setSize(width, height);
                    this.reset();
                    this.center = { x: width / 2, y: height / 2 };
                    this.mouse = { x: this.center.x, y: this.center.y };
                }

                reset() {
                    this.context.font = `${this.fontSize}px ${this.fontFamily}`;
                    const charWidth = this.context.measureText("A").width;
                    this.cols = Math.floor(
                        this.width /
                            (this.fontSize * (charWidth / this.fontSize)),
                    );
                    this.rows = Math.floor(this.height / this.fontSize);
                    this.canvas.width = this.cols;
                    this.canvas.height = this.rows;
                    this.pre.style.fontFamily = this.fontFamily;
                    this.pre.style.fontSize = `${this.fontSize}px`;
                    this.pre.style.margin = "0";
                    this.pre.style.padding = "0";
                    this.pre.style.lineHeight = "1em";
                    this.pre.style.position = "absolute";
                    this.pre.style.left = "0";
                    this.pre.style.top = "0";
                    this.pre.style.zIndex = "9";
                    this.pre.style.backgroundAttachment = "fixed";
                    this.pre.style.mixBlendMode = "difference";
                }

                render(scene, camera) {
                    this.renderer.render(scene, camera);
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    this.context.clearRect(0, 0, w, h);
                    if (this.context && w && h) {
                        this.context.drawImage(
                            this.renderer.domElement,
                            0,
                            0,
                            w,
                            h,
                        );
                    }
                    this.asciify(this.context, w, h);
                    this.hue();
                }

                onMouseMove(e) {
                    this.mouse = {
                        x: e.clientX * PX_RATIO,
                        y: e.clientY * PX_RATIO,
                    };
                }

                get dx() {
                    return this.mouse.x - this.center.x;
                }
                get dy() {
                    return this.mouse.y - this.center.y;
                }

                hue() {
                    const deg = (Math.atan2(this.dy, this.dx) * 180) / Math.PI;
                    this.deg += (deg - this.deg) * 0.075;
                    this.domElement.style.filter = `hue-rotate(${this.deg.toFixed(1)}deg)`;
                }

                asciify(ctx, w, h) {
                    if (w && h) {
                        const imgData = ctx.getImageData(0, 0, w, h).data;
                        let str = "";
                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const i = x * 4 + y * 4 * w;
                                const [r, g, b, a] = [
                                    imgData[i],
                                    imgData[i + 1],
                                    imgData[i + 2],
                                    imgData[i + 3],
                                ];
                                if (a === 0) {
                                    str += " ";
                                    continue;
                                }
                                let gray = (0.3 * r + 0.6 * g + 0.1 * b) / 255;
                                let idx = Math.floor(
                                    (1 - gray) * (this.charset.length - 1),
                                );
                                if (this.invert)
                                    idx = this.charset.length - idx - 1;
                                str += this.charset[idx];
                            }
                            str += "\n";
                        }
                        this.pre.innerHTML = str;
                    }
                }

                dispose() {
                    document.removeEventListener("mousemove", this.onMouseMove);
                }
            }

            class CanvasTxt {
                constructor(
                    txt,
                    {
                        fontSize = 200,
                        fontFamily = "Arial",
                        color = "#fdf9f3",
                    } = {},
                ) {
                    this.canvas = document.createElement("canvas");
                    this.context = this.canvas.getContext("2d");
                    this.txt = txt;
                    this.fontSize = fontSize;
                    this.fontFamily = fontFamily;
                    this.color = color;
                    this.font = `600 ${this.fontSize}px ${this.fontFamily}`;
                }

                setText(txt) {
                    this.txt = txt;
                }

                resize() {
                    this.context.font = this.font;
                    const metrics = this.context.measureText(this.txt);
                    const textWidth = Math.ceil(metrics.width) + 20;
                    const textHeight =
                        Math.ceil(
                            metrics.actualBoundingBoxAscent +
                                metrics.actualBoundingBoxDescent,
                        ) + 20;
                    this.canvas.width = textWidth;
                    this.canvas.height = textHeight;
                }

                render() {
                    this.context.clearRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height,
                    );
                    this.context.fillStyle = this.color;
                    this.context.font = this.font;
                    const metrics = this.context.measureText(this.txt);
                    const yPos = 10 + metrics.actualBoundingBoxAscent;
                    this.context.fillText(this.txt, 10, yPos);
                }

                get width() {
                    return this.canvas.width;
                }
                get height() {
                    return this.canvas.height;
                }
                get texture() {
                    return this.canvas;
                }
            }

            // ============================================================
            //  COUNTDOWN LOGIC
            // ============================================================
            function getCountdownText() {
                const diff = TARGET_DATE - new Date();
                if (diff <= 0) return "Bientot...";
                const d = Math.floor(diff / 86400000);
                const h = Math.floor((diff % 86400000) / 3600000);
                const m = Math.floor((diff % 3600000) / 60000);
                const s = Math.floor((diff % 60000) / 1000);
                return `${String(d).padStart(2, "0")}:${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
            }

            // ============================================================
            //  INIT
            // ============================================================
            async function init() {
                try {
                    await document.fonts.load('600 200px "IBM Plex Mono"');
                    await document.fonts.load('500 12px "IBM Plex Mono"');
                } catch (e) {}
                await document.fonts.ready;

                const container = document.getElementById("ascii-container");
                const { width, height } = container.getBoundingClientRect();
                if (!width || !height) return;

                const asciiFontSize = 6;
                const textFontSize = 150;
                const textColor = "#fdf9f3";
                const planeBaseHeight = 6;
                const enableWaves = false;

                const vertexShader = `
        varying vec2 vUv;
        uniform float uTime;
        uniform float mouse;
        uniform float uEnableWaves;
        void main() {
          vUv = uv;
          float time = uTime * 5.0;
          float waveFactor = uEnableWaves;
          vec3 transformed = position;
          transformed.x += sin(time + position.y) * 0.5 * waveFactor;
          transformed.y += cos(time + position.z) * 0.15 * waveFactor;
          transformed.z += sin(time + position.x) * waveFactor;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
        }
      `;

                const fragmentShader = `
        varying vec2 vUv;
        uniform float mouse;
        uniform float uTime;
        uniform sampler2D uTexture;
        void main() {
          float time = uTime;
          vec2 pos = vUv;
          float move = sin(time + mouse) * 0.01;
          float r = texture2D(uTexture, pos + cos(time * 2.0 - time + pos.x) * 0.01).r;
          float g = texture2D(uTexture, pos + tan(time * 0.5 + pos.x - time) * 0.01).g;
          float b = texture2D(uTexture, pos - cos(time * 2.0 + time + pos.y) * 0.01).b;
          float a = texture2D(uTexture, pos).a;
          gl_FragColor = vec4(r, g, b, a);
        }
      `;

                // Scene setup
                const camera = new THREE.PerspectiveCamera(
                    45,
                    width / height,
                    1,
                    1000,
                );
                camera.position.z = 35;
                const scene = new THREE.Scene();
                let mouse = { x: width / 2, y: height / 2 };

                // Text canvas
                const textCanvas = new CanvasTxt(getCountdownText(), {
                    fontSize: textFontSize,
                    fontFamily: "IBM Plex Mono",
                    color: textColor,
                });
                textCanvas.resize();
                textCanvas.render();

                const texture = new THREE.CanvasTexture(textCanvas.texture);
                texture.minFilter = THREE.NearestFilter;

                const textAspect = textCanvas.width / textCanvas.height;
                const planeW = planeBaseHeight * textAspect;
                const planeH = planeBaseHeight;

                const geometry = new THREE.PlaneGeometry(
                    planeW,
                    planeH,
                    36,
                    36,
                );
                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    uniforms: {
                        uTime: { value: 0 },
                        mouse: { value: 1.0 },
                        uTexture: { value: texture },
                        uEnableWaves: { value: enableWaves ? 1.0 : 0.0 },
                    },
                });

                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                // Renderer + ASCII filter
                const renderer = new THREE.WebGLRenderer({
                    antialias: false,
                    alpha: true,
                });
                renderer.setPixelRatio(1);
                renderer.setClearColor(0x000000, 0);

                const filter = new AsciiFilter(renderer, {
                    fontFamily: "IBM Plex Mono",
                    fontSize: asciiFontSize,
                    invert: true,
                });

                container.appendChild(filter.domElement);
                filter.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                // Update countdown text every second
                let lastText = "";
                setInterval(() => {
                    const newText = getCountdownText();
                    if (newText !== lastText) {
                        lastText = newText;
                        textCanvas.setText(newText);
                        textCanvas.resize();
                        textCanvas.render();
                        texture.needsUpdate = true;

                        // Update plane geometry to match new text aspect ratio
                        const newAspect = textCanvas.width / textCanvas.height;
                        const newW = planeBaseHeight * newAspect;
                        mesh.geometry.dispose();
                        mesh.geometry = new THREE.PlaneGeometry(
                            newW,
                            planeBaseHeight,
                            36,
                            36,
                        );
                    }
                }, 1000);

                // Mouse tracking
                function onMouseMove(evt) {
                    const e = evt.touches ? evt.touches[0] : evt;
                    const bounds = container.getBoundingClientRect();
                    mouse = {
                        x: e.clientX - bounds.left,
                        y: e.clientY - bounds.top,
                    };
                }
                container.addEventListener("mousemove", onMouseMove);
                container.addEventListener("touchmove", onMouseMove);

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);

                    const time = new Date().getTime() * 0.001;
                    textCanvas.render();
                    texture.needsUpdate = true;
                    material.uniforms.uTime.value = Math.sin(time);

                    // Mouse-reactive rotation
                    const rx = Math.map(mouse.y, 0, height, 0.5, -0.5);
                    const ry = Math.map(mouse.x, 0, width, -0.5, 0.5);
                    mesh.rotation.x += (rx - mesh.rotation.x) * 0.05;
                    mesh.rotation.y += (ry - mesh.rotation.y) * 0.05;

                    filter.render(scene, camera);
                }
                animate();

                // Resize handler
                function onResize() {
                    const { width: w, height: h } =
                        container.getBoundingClientRect();
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        filter.setSize(w, h);
                    }
                }
                window.addEventListener("resize", onResize);
            }

            window.addEventListener("load", init);
        </script>
    </body>
</html>
